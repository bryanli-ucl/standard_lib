#pragma once

namespace msd {

/// @brief remove reference
template <typename T> struct remove_reference {
    using type = T;
};
template <typename T> struct remove_reference<T&> {
    using type = T; // l-value reference
};
template <typename T> struct remove_reference<T&&> {
    using type = T; // r-value reference
};
template <typename T> using remove_reference_t = typename remove_reference<T>::type;

/// @brief remove CV
template <typename T> struct remove_cv {
    using type = T;
};
template <typename T> struct remove_cv<const T> {
    using type = T;
};
// volatile
template <typename T> struct remove_cv<volatile T> {
    using type = T;
};
template <typename T> struct remove_cv<const volatile T> {
    using type = T;
};
template <typename T> using remove_cv_t = typename remove_cv<T>::type;

/// @brief enable if
template <bool C, typename T = void> struct enable_if {};
template <typename T> struct enable_if<true, T> {
    using type = T;
};
template <bool C, typename T = void> using enable_if_t = typename enable_if<C, T>::type;

/// @brief conditional
template <bool B, typename T, typename F> struct conditional {
    using type = T;
};
template <typename T, typename F> struct conditional<false, T, F> {
    using type = F;
};
template <bool B, typename T, typename F> using conditional_t = typename conditional<B, T, F>::type;

/// @brief constant value
template <typename T, T Val>
struct constant {
    static constexpr T value = Val;
    using val_t              = T;
    constexpr operator val_t() const noexcept { return value; }
    constexpr val_t operator()() const noexcept { return value; }
};

/// @brief conjunction
template <typename...> struct conjunction : true_type {};
template <typename B1> struct conjunction<B1> : B1 {};
template <typename B1, typename... Bn> struct conjunction<B1, Bn...> : conditional_t<bool(B1::value), conjunction<Bn...>, B1> {};
template <typename... Bn> inline constexpr bool conjunction_v = conjunction<Bn...>::value;

/// @brief disjunction
template <typename...> struct disjunction : false_type {};
template <typename B1> struct disjunction<B1> : B1 {};
template <typename B1, typename... Bn> struct disjunction<B1, Bn...> : conditional_t<bool(B1::value), B1, disjunction<Bn...>> {};
template <typename... Bn> inline constexpr bool disjunction_v = disjunction<Bn...>::value;

/// @brief negation
template <typename B> struct negation : constant<bool, !bool(B::value)> {};
template <typename B> inline constexpr bool negation_v = negation<B>::value;

using true_type  = constant<bool, true>;
using false_type = constant<bool, false>;

/// @brief is integer
namespace __details {
template <typename T> struct is_integral_impl : public false_type {};
template <> struct is_integral_impl<bool> : public true_type {};
template <> struct is_integral_impl<char> : public true_type {};
template <> struct is_integral_impl<signed char> : public true_type {};
template <> struct is_integral_impl<unsigned char> : public true_type {};
template <> struct is_integral_impl<wchar_t> : public true_type {};
template <> struct is_integral_impl<char16_t> : public true_type {};
template <> struct is_integral_impl<char32_t> : public true_type {};
template <> struct is_integral_impl<short> : public true_type {};
template <> struct is_integral_impl<unsigned short> : public true_type {};
template <> struct is_integral_impl<int> : public true_type {};
template <> struct is_integral_impl<unsigned int> : public true_type {};
template <> struct is_integral_impl<long> : public true_type {};
template <> struct is_integral_impl<unsigned long> : public true_type {};
template <> struct is_integral_impl<long long> : public true_type {};
template <> struct is_integral_impl<unsigned long long> : public true_type {};
} // namespace __details
template <typename T> struct is_integral : public __details::is_integral_impl<remove_cv_t<T>> {};
template <typename T> inline constexpr bool is_integral_v = is_integral<T>::value;

/// @brief is bool
namespace __details {
template <typename T> struct is_bool_impl : public false_type {};
template <> struct is_bool_impl<bool> : public true_type {};
} // namespace __details
template <typename T> struct is_bool : public __details::is_bool_impl<remove_cv_t<T>> {};
template <typename T> inline constexpr bool is_bool_v = is_bool<T>::value;

/// @brief is floating point
namespace __details {
template <typename T> struct is_floating_point_impl : public false_type {};
template <> struct is_floating_point_impl<float> : public true_type {};
template <> struct is_floating_point_impl<double> : public true_type {};
template <> struct is_floating_point_impl<long double> : public true_type {};
} // namespace __details
template <typename T> struct is_floating_point : public __details::is_floating_point_impl<remove_cv_t<T>> {};
template <typename T> inline constexpr bool is_floating_point_v = is_floating_point<T>::value;

/// @brief is same
template <typename T, typename U> struct is_same : false_type {};
template <typename T> struct is_same<T, T> : true_type {};
template <typename T, typename U> inline constexpr bool is_same_v = is_same<T, U>::value;

} // namespace msd
