#pragma once

namespace msd {

/// @brief remove reference
template <typename T> struct remove_reference {
    using type = T;
};
template <typename T> struct remove_reference<T&> {
    using type = T; // l-value reference
};
template <typename T> struct remove_reference<T&&> {
    using type = T; // r-value reference
};
template <typename T> using remove_reference_t = typename remove_reference<T>::type;

/// @brief void_t, use to raise an error when not capable
template <typename...> using void_t = void;

/// @brief add r-value reference to a type
template <typename T> struct add_rvalue_reference {
    using type = T&&;
};

template <typename T> typename add_rvalue_reference<T>::type declval() noexcept;

/// @brief remove CV
template <typename T>
struct remove_cv {
    using type = T;
};
template <typename T> struct remove_cv<const T> {
    using type = T;
};
// volatile
template <typename T> struct remove_cv<volatile T> {
    using type = T;
};
template <typename T> struct remove_cv<const volatile T> {
    using type = T;
};
template <typename T> using remove_cv_t = typename remove_cv<T>::type;

/// @brief enable if
template <bool C, typename T = void> struct enable_if {};
template <typename T> struct enable_if<true, T> {
    using type = T;
};
template <bool C, typename T = void> using enable_if_t = typename enable_if<C, T>::type;

/// @brief conditional
template <bool B, typename T, typename F> struct conditional {
    using type = T;
};
template <typename T, typename F> struct conditional<false, T, F> {
    using type = F;
};
template <bool B, typename T, typename F> using conditional_t = typename conditional<B, T, F>::type;

/// @brief constant value
template <typename T, T Val>
struct constant {
    static constexpr T value = Val;
    using val_t              = T;
    constexpr operator val_t() const noexcept { return value; }
    constexpr val_t operator()() const noexcept { return value; }
};

using true_type  = constant<bool, true>;
using false_type = constant<bool, false>;

/// @brief conjunction
template <typename...> struct conjunction : public true_type {};
template <typename Con1> struct conjunction<Con1> : Con1 {};
template <typename Con1, typename... ConN> struct conjunction<Con1, ConN...> : conditional_t<bool(Con1::value), conjunction<ConN...>, Con1> {};
// template <typename... ConN> inline constexpr bool conjunction_v = conjunction<ConN...>::value;

/// @brief disjunction
template <typename...> struct disjunction : public false_type {};
template <typename Con1> struct disjunction<Con1> : Con1 {};
template <typename Con1, typename... ConN> struct disjunction<Con1, ConN...> : conditional_t<bool(Con1::value), Con1, disjunction<ConN...>> {};
// template <typename... ConN> inline constexpr bool disjunction_v = disjunction<ConN...>::value;

/// @brief negation
template <typename B> struct negation : constant<bool, !bool(B::value)> {};
// template <typename B> inline constexpr bool negation_v = negation<B>::value;

namespace __details {
template <typename T> struct is_integral_impl : public false_type {};
template <> struct is_integral_impl<bool> : public true_type {};
template <> struct is_integral_impl<char> : public true_type {};
template <> struct is_integral_impl<signed char> : public true_type {};
template <> struct is_integral_impl<unsigned char> : public true_type {};
template <> struct is_integral_impl<wchar_t> : public true_type {};
template <> struct is_integral_impl<char16_t> : public true_type {};
template <> struct is_integral_impl<char32_t> : public true_type {};
template <> struct is_integral_impl<short> : public true_type {};
template <> struct is_integral_impl<unsigned short> : public true_type {};
template <> struct is_integral_impl<int> : public true_type {};
template <> struct is_integral_impl<unsigned int> : public true_type {};
template <> struct is_integral_impl<long> : public true_type {};
template <> struct is_integral_impl<unsigned long> : public true_type {};
template <> struct is_integral_impl<long long> : public true_type {};
template <> struct is_integral_impl<unsigned long long> : public true_type {};
} // namespace __details
/// is integer
template <typename T> struct is_integral : public __details::is_integral_impl<remove_cv_t<T>> {};
// template <typename T> inline constexpr bool is_integral_v = is_integral<T>::value;


namespace __details {
template <typename T> struct is_bool_impl : public false_type {};
template <> struct is_bool_impl<bool> : public true_type {};
} // namespace __details
/// is bool
template <typename T> struct is_bool : public __details::is_bool_impl<remove_cv_t<T>> {};
// template <typename T> inline constexpr bool is_bool_v = is_bool<T>::value;


namespace __details {
template <typename T> struct is_floating_point_impl : public false_type {};
template <> struct is_floating_point_impl<float> : public true_type {};
template <> struct is_floating_point_impl<double> : public true_type {};
template <> struct is_floating_point_impl<long double> : public true_type {};
} // namespace __details
/// is floating point
template <typename T> struct is_floating_point : public __details::is_floating_point_impl<remove_cv_t<T>> {};
// template <typename T> inline constexpr bool is_floating_point_v = is_floating_point<T>::value;


/// is same
template <typename T, typename U> struct is_same : false_type {};
template <typename T> struct is_same<T, T> : true_type {};
// template <typename T, typename U> inline constexpr bool is_same_v = is_same<T, U>::value;


namespace __details {
template <typename T, typename = void> struct is_move_constructible_impl : false_type {};
template <typename T> struct is_move_constructible_impl<T, void_t<decltype(T(declval<T&&>()))>> : true_type {};
template <typename T, typename = void> struct is_nothrow_move_constructible_impl : false_type {};
template <typename T> struct is_nothrow_move_constructible_impl<T, void_t<decltype(T(declval<T&&>()))>> {
    static constexpr bool value = noexcept(T(declval<T&&>()));
};


template <typename T, typename = void> struct is_move_assignable_impl : false_type {};
template <typename T> struct is_move_assignable_impl<T, void_t<decltype((declval<T&>() = declval<T&&>()))>> : true_type {};
template <typename T, typename = void> struct is_nothrow_move_assignable_impl : false_type {};
template <typename T> struct is_nothrow_move_assignable_impl<T, void_t<decltype(declval<T&>() = declval<T&&>())>> {
    static constexpr bool value = noexcept(declval<T&>() = declval<T&&>());
};
} // namespace __details
/// is move constructible
template <typename T> struct is_move_constructible : __details::is_move_constructible_impl<T> {};
/// is move and no-throw constructible
template <typename T> struct is_nothrow_move_constructible : __details::is_nothrow_move_constructible_impl<T> {};
/// is move assignable
template <typename T> struct is_move_assignable : __details::is_move_assignable_impl<T> {};
/// is move and no-throw assignable
template <typename T> struct is_nothrow_move_assignable : __details::is_nothrow_move_assignable_impl<T> {};


} // namespace msd
