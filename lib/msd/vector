#pragma once

#include <stddef.h>

#include <initializer_list>
#include <iterator>
#include <move>

#include <avr-memory.hpp>

namespace msd {
template <typename T>
class vector {
    using data_t         = T;
    using data_ref       = T&;
    using data_const_ref = const T&;
    using data_ptr       = T*;
    using data_const_ptr = const T*;

    private:
    data_ptr m_data;
    size_t m_capacity;
    size_t m_size;

    void deallocate() {
        if (m_data == nullptr) return;
        for (size_t i = 0; i < m_size; i++)
            m_data[i].~T();
        ::operator delete(m_data);
        m_data = nullptr;
    }

    void reallocate(size_t n_cap) {
        data_ptr n_data = static_cast<data_ptr>(::operator new(n_cap * sizeof(data_t)));

        size_t n_sz = (m_size < n_cap) ? m_size : n_cap;

        for (size_t i = 0; i < n_sz; ++i) {
            new (&n_data[i]) data_t(msd::move(m_data[i]));
        }

        deallocate();

        m_data     = n_data;
        m_size     = n_sz;
        m_capacity = n_cap;
    }

    public:
    constexpr vector() noexcept : m_data(nullptr), m_capacity(0), m_size(0) {}
    ~vector() noexcept { deallocate(); }

    explicit vector(size_t n) noexcept : m_data(nullptr), m_capacity(0), m_size(0) {
        if (n <= 0) return;
        m_data     = static_cast<data_ptr>(::operator new(n * sizeof(data_t)));
        m_capacity = n;
        for (size_t i = 0; i < n; i++, m_size++)
            new (&m_data[i]) data_t();
    }

    vector(size_t n, data_const_ref val) noexcept : m_data(nullptr), m_capacity(0), m_size(0) {
        if (n <= 0) return;

        m_data     = static_cast<data_ptr>(::operator new(n * sizeof(T)));
        m_capacity = n;
        for (size_t i = 0; i < n; i++, m_size++)
            new (&m_data[i]) data_t(val);
    }

    vector(std::initializer_list<T> list) noexcept : m_data(nullptr), m_capacity(0), m_size(0) {
        if (list.size() <= 0) return;

        m_data     = static_cast<data_ptr>(::operator new(list.size() * sizeof(data_t)));
        m_capacity = list.size();
        for (const auto& x : list) {
            new (&m_data[m_size]) data_t(x);
            m_size++;
        }
    }

    // copy constructor
    vector(const vector& other) noexcept : m_data(nullptr), m_capacity(0), m_size(0) {
        if (other.m_size <= 0) return;

        m_data     = static_cast<data_ptr>(::operator new(other.m_capacity * sizeof(data_t)));
        m_capacity = other.m_capacity;

        for (size_t i = 0; i < other.m_size; ++i) {
            new (&m_data[i]) data_t(other.m_data[i]);
            ++m_size;
        }
    }

    vector& operator=(const vector& other) {
        if (this == &other) return *this;

        deallocate();

        m_size     = 0;
        m_capacity = 0;

        if (other.m_size == 0) return *this;

        m_data     = static_cast<data_ptr>(::operator new(other.m_capacity * sizeof(data_t)));
        m_capacity = other.m_capacity;
        for (size_t i = 0; i < other.m_size; ++i) {
            new (&m_data[i]) data_t(other.m_data[i]);
            ++m_size;
        }

        return *this;
    }

    // move constructor
    vector(vector&& other) noexcept : m_data(other.m_data), m_capacity(other.m_capacity), m_size(other.m_size) {
        other.m_data     = nullptr;
        other.m_size     = 0;
        other.m_capacity = 0;
    }

    vector& operator=(vector&& other) noexcept {
        if (this == &other) return *this;

        deallocate();

        m_data     = other.m_data;
        m_size     = other.m_size;
        m_capacity = other.m_capacity;

        other.m_data     = nullptr;
        other.m_size     = 0;
        other.m_capacity = 0;

        return *this;
    }

    data_ref operator[](size_t n) { return m_data[n]; }
    data_const_ref operator[](size_t n) const { return m_data[n]; }

    data_ref at(size_t n) { return m_data[(n < m_size) ? n : 0]; }
    data_const_ref at(size_t n) const { return m_data[(n < m_size) ? n : 0]; }

    data_ptr data() noexcept { return m_data; }
    data_const_ptr data() const noexcept { return m_data; }

    msd::iterator<data_t> begin() noexcept { return msd::iterator<data_t>(m_data); }
    msd::iterator<data_t> end() noexcept { return msd::iterator<data_t>(m_data + m_size); }

    size_t size() noexcept { return m_size; }
    size_t capacity() noexcept { return m_capacity; }
    bool empty() noexcept { return m_size == 0; }
    void reserve(size_t n_cap) {
        if (n_cap <= m_capacity) return;
        reallocate(n_cap);
    }

    void clear() noexcept {
        for (size_t i = 0; i < m_size; i++)
            m_data[i].~data_t();
        m_size = 0;
    }

    void push_back(data_const_ref value) {
        if (m_size >= m_capacity)
            reserve((m_capacity == 0) ? 16 : m_capacity * 2);

        new (&m_data[m_size]) data_t(value);
        m_size++;
    }

    void push_back(T&& value) {
        if (m_size >= m_capacity)
            reserve((m_capacity == 0) ? 16 : m_capacity * 2);

        new (&m_data[m_size]) data_t(msd::move(value));
        m_size++;
    }

    template <typename... Args>
    data_ref emplace_back(Args&&... args) {
        if (m_size >= m_capacity)
            reserve((m_capacity == 0) ? 16 : m_capacity * 2);

        new (&m_data[m_size]) data_t(msd::forward<Args>(args)...);
        return m_data[m_size++];
    }

    void swap(vector& other) noexcept {
        msd::swap(m_data, other.m_data);
        msd::swap(m_size, other.m_size);
        msd::swap(m_capacity, other.m_capacity);
    }
};

template <typename T>
void swap(vector<T>& lhs, vector<T>& rhs) noexcept {
    lhs.swap(rhs);
}

} // namespace msd
