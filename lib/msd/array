#pragma once

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <iterator>

namespace msd {
template <typename T, size_t N>
class array {
    using data_t   = T;
    using data_ptr = T*;
    using data_ref = T&;

    private:
    data_t m_data[N];

    public:
    array()
    : m_data{} {}

    template <typename... Args>
    array(Args... args) { initializer(0, args...); }

    virtual ~array() = default;

    const data_t& at(size_t p) const { return m_data[p >= N ? N - 1 : p]; }
    data_t& at(size_t p) { return m_data[p >= N ? N - 1 : p]; }
    const data_t& operator[](const size_t index) const { return at(index); }
    data_t& operator[](const size_t index) { return at(index); }

    msd::iterator<data_t> begin() { return iterator<data_t>{ m_data }; }
    msd::iterator<data_t> end() { return iterator<data_t>{ m_data + N }; }

    constexpr size_t size() const { return N; }
    constexpr size_t capacity() const { return N; }
    constexpr bool empty() const { return size() == 0; }

    size_t fill(data_t val) {
        for (size_t i = 0; i < N; i++) {
            m_data[i] = val;
        }
        return N;
    }

    bool operator!=(const array& other) { return (*this == other); }
    bool operator==(const array& other) {
        if (other.size() != N) return false;

        for (size_t i = 0; i < N; i++) {
            if (m_data[i] != other.at(i)) return false;
        }
        return true;
    }

    private:
    void initializer(size_t index) {
        for (; index < N; index++)
            m_data[index] = data_t{};
    }

    template <typename M, typename... Args>
    void initializer(size_t index, M val, Args... args) {
        if (index >= N)
            return;
        m_data[index] = static_cast<data_t>(val);
        initializer(index + 1, args...);
    }
};

template <typename T, typename... Args>
array<T, sizeof...(Args) + 1> make_array(T arg1, Args... args) {
    return array<T, sizeof...(Args) + 1>{ static_cast<T>(arg1), static_cast<T>(args)... };
}

} // namespace msd
