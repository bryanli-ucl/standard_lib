#pragma once

#include "avr-def.hpp"
#include "avr-memory.hpp"

namespace msd {

template <size_t BlockSizeT, size_t NumBlockT, typename T = uint8_t>
class MemoryPool {
    using data_t   = T;
    using data_ptr = T*;
    using data_ref = T&;

    struct Block {
        size_t block_size;
        Block* next;
    };

    using mcb_t   = MemoryControlBlock;
    using mcb_ptr = MemoryControlBlock*;
    using mcb_ref = MemoryControlBlock&;

    private:
    data_ptr m_pool_start; // pool start pointer
    data_ptr m_pool_end;   // pool end pointer
    size_t m_total_size;   // pool totoal size
    size_t m_used_size;    // pool used size
    size_t m_alloc_count;  // number of allocation
    mcb_t* m_free_list;    // store first free node

    // do not allow copy construct
    MemoryPool(const MemoryPool&)            = delete;
    MemoryPool& operator=(const MemoryPool&) = delete;

    public:
    MemoryPool() noexcept
    : m_pool_start(nullptr), m_pool_end(nullptr), m_total_size(0),
      m_used_size(0), m_alloc_count(0), m_free_list(nullptr) {}

    // initialize memory pool
    bool init(void* memory, size_t size) noexcept {
        // are you kindding me ?
        if (memory == nullptr || size < sizeof(mcb_t) + 8) return false;

        m_pool_start  = static_cast<data_ptr>(memory);
        m_pool_end    = m_pool_start + size;
        m_total_size  = size;
        m_used_size   = 0;
        m_alloc_count = 0;

        // put all memory into one node
        m_free_list               = reinterpret_cast<MemoryControlBlock*>(m_pool_start);
        m_free_list->block_size   = size;
        m_free_list->is_allocated = false;
        m_free_list->next         = nullptr;

        return true;
    }
    1 void* allocate(size_t size) noexcept {
        if (size == 0 || m_free_list == nullptr) {
            return nullptr;
        }

        size = align_up<8>(size);

        size_t required_size = size + sizeof(MemoryControlBlock);

        MemoryControlBlock* prev    = nullptr;
        MemoryControlBlock* current = m_free_list;

        // 首次适配算法
        while (current) {
            if (!current->is_allocated && current->block_size >= required_size) {
                // 找到合适的块
                if (current->block_size >= required_size + sizeof(MemoryControlBlock) + 8) {
                    // 可以分割内存块
                    MemoryControlBlock* new_block = reinterpret_cast<MemoryControlBlock*>(
                    reinterpret_cast<uint8_t*>(current) + required_size);
                    new_block->block_size   = current->block_size - required_size;
                    new_block->is_allocated = false;
                    new_block->next         = current->next;

                    current->block_size = required_size;
                    current->next       = new_block;
                }

                current->is_allocated = true;
                m_used_size += current->block_size;
                m_alloc_count++;

                // 从空闲链表中移除
                if (prev) {
                    prev->next = current->next;
                } else {
                    m_free_list = current->next;
                }

                // 返回用户可用内存（跳过控制头）
                return reinterpret_cast<uint8_t*>(current) + sizeof(MemoryControlBlock);
            }
            prev    = current;
            current = current->next;
        }

        return nullptr;
    }

    // return memory
    bool deallocate(void* ptr) noexcept {
        // check ptr not none
        if (ptr == nullptr) return false;

        // check ptr in this pool
        if (ptr < m_pool_start || ptr >= m_pool_end) return false;

        // get block control head
        MemoryControlBlock* block = reinterpret_cast<MemoryControlBlock*>(
        static_cast<uint8_t*>(ptr) - sizeof(MemoryControlBlock));

        // check double free
        if (!block->is_allocated) return false;

        m_used_size -= block->block_size;
        block->is_allocated = false;
        merge_free_blocks(block);
        block->next = m_free_list;
        m_free_list = block;

        return true;
    }

    size_t get_total_size() const noexcept { return m_total_size; }
    size_t get_used_size() const noexcept { return m_used_size; }
    size_t get_free_size() const noexcept { return m_total_size - m_used_size; }
    size_t get_allocation_count() const noexcept { return m_alloc_count; }
    bool empty() const noexcept { return m_used_size == 0; }

    void reset() noexcept {
        m_free_list               = reinterpret_cast<MemoryControlBlock*>(m_pool_start);
        m_free_list->block_size   = m_total_size;
        m_free_list->is_allocated = false;
        m_free_list->next         = nullptr;
        m_used_size               = 0;
        m_alloc_count             = 0;
    }

    private:
    template <size_t align>
    size_t align_up(size_t n) {
        static_assert(align & (align - 1) == 0, "align must be 2^n");
        return (n + (align - 1)) & align - 1;
    }

    // 合并空闲块
    void merge_free_blocks(MemoryControlBlock* block) noexcept {
        MemoryControlBlock* current = m_free_list;

        while (current) {
            // 检查是否可以与后面的块合并
            uint8_t* current_end = reinterpret_cast<uint8_t*>(current) + current->block_size;
            if (current_end == reinterpret_cast<uint8_t*>(block)) {
                // 当前块后面是释放的块
                current->block_size += block->block_size;
                return;
            }

            // 检查是否可以与前面的块合并
            uint8_t* block_end = reinterpret_cast<uint8_t*>(block) + block->block_size;
            if (block_end == reinterpret_cast<uint8_t*>(current)) {
                // 释放的块后面是当前块
                block->block_size += current->block_size;
                block->next = current->next;

                // 从链表中移除当前块
                MemoryControlBlock* prev = m_free_list;
                if (prev == current) {
                    m_free_list = block;
                } else {
                    while (prev && prev->next != current) {
                        prev = prev->next;
                    }
                    if (prev) {
                        prev->next = block;
                    }
                }
                return;
            }
            current = current->next;
        }
    }
};

} // namespace msd